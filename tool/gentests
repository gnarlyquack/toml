#!/usr/bin/env python3

import datetime
import json
import os
import re
import sys

from os.path import dirname


ROOT_PATH = dirname(dirname(os.path.realpath(__file__)))

SOURCE_DIR = os.path.join(ROOT_PATH, "dep", "toml-test", "tests")

TEST_DIR = os.path.join(ROOT_PATH, "test")

STRING_CONVERT = str.maketrans({
    '\n':   r'\n',
    '"':    r'\"',
    '\\':   r'\\',
})


NAME_CONVERT = str.maketrans({
    '/': '_',
    '-': '_',
})


EXCLUDE = {
    # These tests are no longer valid for TOML 1.0.0
    os.path.join(SOURCE_DIR, "valid", "string", "escape-esc"),
}


def main():
    # ensure test directory exists
    os.makedirs(TEST_DIR, exist_ok=True)

    files = []
    updated_files = generate_valid_tests("valid", files)

    testfile = os.path.join(TEST_DIR, "valid_tests.cpp")
    if updated_files or not os.path.exists(testfile):
        with open(testfile, "w") as fh:
            fh.write(TEST_FILE_TEMPLATE.format('"\n#include "'.join(files)))

    files.clear()
    updated_files = generate_invalid_tests("invalid", files)
    testfile = os.path.join(TEST_DIR, "invalid_tests.cpp")
    if updated_files or not os.path.exists(testfile):
        with open(testfile, "w") as fh:
            fh.write(TEST_FILE_TEMPLATE.format('"\n#include "'.join(files)))

    sys.exit()


TEST_FILE_TEMPLATE = '''\
#include "test_common.hpp"

using namespace std;
using namespace toml;

#include "{}"
'''


VALID_TEST_TEMPLATE = b'''\
TEST(%b, %b)
{
    const string toml{"%b", %d};

    const Table expected{%b};

    assert_parsed(toml, expected);
}
'''


INVALID_TEST_TEMPLATE = b'''\
TEST(%b, %b)
{
    const string toml{"%b", %d};

    const vector<Error> expected{
        { 0, 0, "" },
    };

    assert_errors(toml, expected);
}
'''


def generate_valid_tests(relative_src_dir, files):
    suitename = relative_src_dir.translate(NAME_CONVERT) + "_tests"
    src_dir = os.path.join(SOURCE_DIR, relative_src_dir)
    test_dir = os.path.join(TEST_DIR, relative_src_dir)
    os.makedirs(test_dir, exist_ok=True)

    updated_files = False
    sources = set()
    tests = set()

    with os.scandir(src_dir) as it:
        for entry in it:
            if entry.is_dir():
                # append directory separator to ensure no clashes with file names
                name = entry.name + os.path.sep
                sources.add(name)
            elif entry.path.endswith(".toml"):
                # use the base name so we can match TOML files to C++ files
                name = entry.name.rsplit('.', 1)[0]
                if os.path.join(src_dir, name) not in EXCLUDE:
                    sources.add(name)

    with os.scandir(test_dir) as it:
        for entry in it:
            if entry.is_dir():
                # append directory separator to ensure no clashes with file names
                name = entry.name + os.path.sep
                tests.add(name)
            else:
                # use the base name so we can match TOML files to C++ files
                name = entry.name.rsplit('.', 1)[0]
                tests.add(name)

    for src in sources:
        src_path = os.path.join(src_dir, src)
        if os.path.isdir(src_path):
            if generate_valid_tests(os.path.join(relative_src_dir, src.rstrip(os.path.sep)), files):
                updated_files = True
            tests.discard(src)

        else:
            with open(f"{src_path}.toml", "rb") as fh:
                toml = fh.read()

            with open(f"{src_path}.json", "r") as fh:
                expected = fh.read()
            expected = json.JSONDecoder().decode(expected)
            expected = convert_result(expected)

            testname = f"test_{src.replace('-', '_')}"
            result = VALID_TEST_TEMPLATE % (
                    suitename.encode("UTF-8"),
                    testname.encode("UTF-8"),
                    escape_bytes(toml),
                    len(toml),
                    expected.encode("UTF-8"),
                )

            testfile = f"{src}.cpp"
            testpath = os.path.join(test_dir, testfile)

            if src in tests:
                tests.remove(src)
                with open(testpath, "rb") as fh:
                    current = fh.read()
            else:
                current = None

            if result != current:
                if current is None:
                    print(f"Adding test: {os.path.join(relative_src_dir, testfile)}")
                    updated_files = True
                else:
                    print(f"Updating test: {os.path.join(relative_src_dir, testfile)}")

                with open(testpath, "wb") as fh:
                    fh.write(result)

            files.append(os.path.join(relative_src_dir, testfile))

    if tests:
        updated_files = True
        for test in tests:
            test_path = os.path.join(test_dir, test)
            if os.path.isdir(test_path):
                print(f"Removing test directory: {os.path.join(relative_src_dir, test)}")
                for root, dirs, files in os.walk(test_path, topdown=False):
                    for name in files:
                        os.remove(os.path.join(root, name))
                    for name in dirs:
                        os.rmdir(os.path.join(root, name))
                os.rmdir(test_path)

            else:
                test += ".cpp"
                test_path += ".cpp"
                print(f"Removing test: {os.path.join(relative_src_dir, test)}")
                os.remove(test_path)

    return updated_files


def generate_invalid_tests(relative_src_dir, files):
    suitename = relative_src_dir.translate(NAME_CONVERT) + "_tests"
    src_dir = os.path.join(SOURCE_DIR, relative_src_dir)
    test_dir = os.path.join(TEST_DIR, relative_src_dir)
    os.makedirs(test_dir, exist_ok=True)

    updated_files = False
    sources = set()
    tests = set()

    with os.scandir(src_dir) as it:
        for entry in it:
            if entry.is_dir():
                # append directory separator to ensure no clashes with file names
                name = entry.name + os.path.sep
                sources.add(name)
            elif entry.path.endswith(".toml"):
                # use the base name so we can match TOML files to C++ files
                name = entry.name.rsplit('.', 1)[0]
                if os.path.join(src_dir, name) not in EXCLUDE:
                    sources.add(name)

    with os.scandir(test_dir) as it:
        for entry in it:
            if entry.is_dir():
                # append directory separator to ensure no clashes with file names
                name = entry.name + os.path.sep
                tests.add(name)
            else:
                # use the base name so we can match TOML files to C++ files
                name = entry.name.rsplit('.', 1)[0]
                tests.add(name)

    for src in sources:
        src_path = os.path.join(src_dir, src)
        if os.path.isdir(src_path):
            if generate_invalid_tests(os.path.join(relative_src_dir, src.rstrip(os.path.sep)), files):
                updated_files = True
            tests.discard(src)

        else:
            with open(f"{src_path}.toml", "rb") as fh:
                toml = fh.read()

            testname = f"test_{src.replace('-', '_')}"
            result = INVALID_TEST_TEMPLATE % (
                    suitename.encode("UTF-8"),
                    testname.encode("UTF-8"),
                    escape_bytes(toml),
                    len(toml),
                )

            testfile = f"{src}.cpp"
            testpath = os.path.join(test_dir, testfile)

            if src in tests:
                tests.remove(src)
                with open(testpath, "rb") as fh:
                    current = fh.read()

                replacement = (b'toml{"%b", %d};\n' % (escape_bytes(toml), len(toml))).replace(b'\\', b'\\\\')
                result = re.sub(b'toml\\{.*\\};\n', replacement, current)
            else:
                current = None

            if result != current:
                if current is None:
                    print(f"Adding test: {os.path.join(relative_src_dir, testfile)}")
                    updated_files = True
                else:
                    print(f"Updating test: {os.path.join(relative_src_dir, testfile)}")

                with open(testpath, "wb") as fh:
                    fh.write(result)

            files.append(os.path.join(relative_src_dir, testfile))

    if tests:
        updated_files = True
        for test in tests:
            test_path = os.path.join(test_dir, test)
            if os.path.isdir(test_path):
                print(f"Removing test directory: {os.path.join(relative_src_dir, test)}")
                for root, dirs, files in os.walk(test_path, topdown=False):
                    for name in files:
                        os.remove(os.path.join(root, name))
                    for name in dirs:
                        os.rmdir(os.path.join(root, name))
                os.rmdir(test_path)

            else:
                test += ".cpp"
                test_path += ".cpp"
                print(f"Removing test: {os.path.join(relative_src_dir, test)}")
                os.remove(test_path)

    return updated_files


def convert_result(value, child=False):
    if type(value) is list:
        result = "new ArrayValue({"
        for element in value:
            converted = convert_result(element, True)
            result += converted + ','
        result += "})"

    else:
        assert type(value) is dict

        if (*value.keys(), ) == ("type", "value"):
            if value['type'] == "integer":
                result = "new IntegerValue({}ULL)".format(value['value'])

            elif value['type'] == "float":
                converted = value['value']
                if "nan" in converted:
                    converted = converted.replace("nan", "NAN64")
                elif "inf" in converted:
                    converted = converted.replace("inf", "INF64")
                result = "new FloatValue({})".format(converted)

            elif value['type'] == "bool":
                assert value['value'] in {"true", "false"}
                result = "new BooleanValue({})".format(value['value'])

            elif value['type'] == "datetime":
                dt_format = "%Y-%m-%dT%H:%M:%S"
                if '.' in value['value']:
                    dt_format += ".%f"
                if 'Z' in value['value']:
                    value['value'] = value['value'].replace('Z', '+00:00')
                if ('+' in value['value']) or ('-' in value['value']):
                    dt_format += "%z"
                converted = datetime.datetime.strptime(value['value'], dt_format)
                converted = converted.astimezone(datetime.timezone(datetime.timedelta(0)))
                result = ("new OffsetDateTimeValue("
                            "date::sys_days(date::year({}) / date::month({}) / date::day({})) "
                            "+ chrono::hours({}) "
                            "+ chrono::minutes({}) "
                            "+ chrono::seconds({}) "
                            "+ chrono::microseconds({}))"
                          ).format(
                                converted.year, converted.month, converted.day,
                                converted.hour, converted.minute, converted.second, converted.microsecond)

            elif value['type'] == "datetime-local":
                converted = datetime.datetime.fromisoformat(value['value'])
                result = ("new LocalDateTimeValue("
                            "LocalDate(date::year({}) / date::month({}) / date::day({})) "
                            "+ chrono::hours({}) "
                            "+ chrono::minutes({}) "
                            "+ chrono::seconds({}) "
                            "+ chrono::microseconds({}))"
                          ).format(
                                converted.year, converted.month, converted.day,
                                converted.hour, converted.minute, converted.second, converted.microsecond)

            elif value['type'] == "date-local":
                converted = datetime.date.fromisoformat(value['value'])
                result = "new LocalDateValue(LocalDate(date::year({}) / date::month({}) / date::day({})))".format(
                        converted.year, converted.month, converted.day)

            elif value['type'] == "time-local":
                converted = datetime.time.fromisoformat(value['value'])
                result = "new LocalTimeValue(LocalTime(chrono::hours({}) + chrono::minutes({}) + chrono::seconds({}) + chrono::microseconds({})))".format(
                        converted.hour, converted.minute, converted.second, converted.microsecond)

            else:
                assert value['type'] == "string"
                result = "new StringValue(\"{}\")".format(escape_string(value['value']))

        else:
            result = ""
            if child:
                result = "new TableValue({"

            for k, v in value.items():
                converted = convert_result(v, True)
                result += "{{ \"{}\", {} }},".format(k.translate(STRING_CONVERT), converted)

            if child:
                result += "})"

    return result


def convert_error(error):
    result = "{{ {}, {}, \"{}\" }},".format(error['line'], error['char'], escape_string(error['message']))
    return result;


def escape_bytes(value):
    result = bytearray()

    for c in value:
        if c == 34:
            result.extend(b'\\"')
        elif c == 92:
            result.extend(b'\\\\')
        elif c >= 32 and c <= 126:
            result.append(c)
        elif c == 8:
            result.extend(b'\\b')
        elif c == 9:
            result.extend(b'\\t')
        elif c == 10:
            result.extend(b'\\n')
        elif c == 11:
            result.extend(b'\\v')
        elif c == 12:
            result.extend(b'\\f')
        elif c == 13:
            result.extend(b'\\r')
        else:
            result.extend(b'\\%03o' % c)

    return result


def escape_string(value):
    result = ''

    for c in value:
        if c == '"':
            result += '\\"'
        elif c == '\\':
            result += '\\\\'
        elif c.isprintable():
            result += c
        elif c == '\b':
            result += '\\b'
        elif c == '\t':
            result += '\\t'
        elif c == '\n':
            result += '\\n'
        elif c == '\v':
            result += '\\v'
        elif c == '\f':
            result += '\\f'
        elif c == '\r':
            result += '\\r'
        else:
            c = ord(c)
            if c > 9999:
                result += '\\U{:0>8X}""'.format(c)
            else:
                result += '\\u{:0>4X}'.format(c)

    return result


if __name__ == "__main__":
    main()
