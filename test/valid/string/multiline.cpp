TEST(valid_string_tests, test_multiline)
{
    const string toml{"# NOTE: this file includes some literal tab characters.\n\nmultiline_empty_one = \"\"\"\"\"\"\n\n# A newline immediately following the opening delimiter will be trimmed.\nmultiline_empty_two = \"\"\"\n\"\"\"\n\n# \\ at the end of line trims newlines as well; note that last \\ is followed by\n# two spaces, which are ignored.\nmultiline_empty_three = \"\"\"\\\n    \"\"\"\nmultiline_empty_four = \"\"\"\\\n   \\\n   \\  \n   \"\"\"\n\nequivalent_one = \"The quick brown fox jumps over the lazy dog.\"\nequivalent_two = \"\"\"\nThe quick brown \\\n\n\n  fox jumps over \\\n    the lazy dog.\"\"\"\n\nequivalent_three = \"\"\"\\\n       The quick brown \\\n       fox jumps over \\\n       the lazy dog.\\\n       \"\"\"\n\nwhitespace-after-bs = \"\"\"\\\n       The quick brown \\\n       fox jumps over \\   \n       the lazy dog.\\\t\n       \"\"\"\n\nno-space = \"\"\"a\\\n    b\"\"\"\n\n# Has tab character.\nkeep-ws-before = \"\"\"a   \t\\\n   b\"\"\"\n\nescape-bs-1 = \"\"\"a \\\\\nb\"\"\"\n\nescape-bs-2 = \"\"\"a \\\\\\\nb\"\"\"\n\nescape-bs-3 = \"\"\"a \\\\\\\\\n  b\"\"\"\n", 927};

    const Table expected{{ "equivalent_one", Value::of_string("The quick brown fox jumps over the lazy dog.") },{ "equivalent_three", Value::of_string("The quick brown fox jumps over the lazy dog.") },{ "equivalent_two", Value::of_string("The quick brown fox jumps over the lazy dog.") },{ "escape-bs-1", Value::of_string("a \\\nb") },{ "escape-bs-2", Value::of_string("a \\b") },{ "escape-bs-3", Value::of_string("a \\\\\n  b") },{ "keep-ws-before", Value::of_string("a   \tb") },{ "multiline_empty_four", Value::of_string("") },{ "multiline_empty_one", Value::of_string("") },{ "multiline_empty_three", Value::of_string("") },{ "multiline_empty_two", Value::of_string("") },{ "no-space", Value::of_string("ab") },{ "whitespace-after-bs", Value::of_string("The quick brown fox jumps over the lazy dog.") }};

    assert_parsed(toml, expected);
}
